/**
 * This file is generated automatically. Do not edit this file.
 */
typealias ID = String
enum AlignItems: String, Decodable, Encodable {
  case START = "START"
  case CENTER = "CENTER"
  case END = "END"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try AlignItems(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct ApiHttpHeader: Decodable, Encodable {
  var name: String?
  var value: String?
}
struct ApiHttpRequest: Decodable, Encodable {
  var url: String?
  var method: ApiHttpRequestMethod?
  var headers: [ApiHttpHeader]?
  var body: String?
}
enum ApiHttpRequestMethod: String, Decodable, Encodable {
  case GET = "GET"
  case POST = "POST"
  case PUT = "PUT"
  case DELETE = "DELETE"
  case PATCH = "PATCH"
  case HEAD = "HEAD"
  case TRACE = "TRACE"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try ApiHttpRequestMethod(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct ApiHttpResponseAssertion: Decodable, Encodable {
  var statusCodes: [Int]?
}
struct BoxShadow: Decodable, Encodable {
  var color: Color?
  var offsetX: Int?
  var offsetY: Int?
  var radius: Int?
}
enum BuiltinUserProperty: String, Decodable, Encodable {
  case userId = "userId"
  case userRnd = "userRnd"
  case languageCode = "languageCode"
  case regionCode = "regionCode"
  case currentTime = "currentTime"
  case firstBootTime = "firstBootTime"
  case lastBootTime = "lastBootTime"
  case retentionPeriod = "retentionPeriod"
  case bootingTime = "bootingTime"
  case sdkVersion = "sdkVersion"
  case osVersion = "osVersion"
  case osName = "osName"
  case appId = "appId"
  case appVersion = "appVersion"
  case cfBundleVersion = "cfBundleVersion"
  case localYear = "localYear"
  case localMonth = "localMonth"
  case localWeekday = "localWeekday"
  case localDay = "localDay"
  case localHour = "localHour"
  case localMinute = "localMinute"
  case localSecond = "localSecond"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try BuiltinUserProperty(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum CollectionKind: String, Decodable, Encodable {
  case CAROUSEL = "CAROUSEL"
  case SCROLL = "SCROLL"
  case GRID = "GRID"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try CollectionKind(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct Color: Decodable, Encodable {
  var red: Float?
  var green: Float?
  var blue: Float?
  var alpha: Float?
}
enum ConditionOperator: String, Decodable, Encodable {
  case Regex = "Regex"
  case Equal = "Equal"
  case NotEqual = "NotEqual"
  case GreaterThan = "GreaterThan"
  case GreaterThanOrEqual = "GreaterThanOrEqual"
  case LessThan = "LessThan"
  case LessThanOrEqual = "LessThanOrEqual"
  case In = "In"
  case NotIn = "NotIn"
  case Between = "Between"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try ConditionOperator(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct ExperimentCondition: Decodable, Encodable {
  var property: String?
  var asType: UserPropertyType?
  var `operator`: String?
  var value: String?
}
struct ExperimentConfig: Decodable, Encodable {
  var id: ID?
  var kind: ExperimentKind?
  var distribution: [ExperimentCondition]?
  var eventFrequencyConditions: [UserEventFrequencyCondition]?
  var baseline: ExperimentVariant?
  var variants: [ExperimentVariant]?
  var seed: Int?
  var frequency: ExperimentFrequency?
  var startedAt: DateTime?
  var endedAt: DateTime?
}
struct ExperimentConfigs: Decodable, Encodable {
  var configs: [ExperimentConfig]?
}
struct ExperimentFrequency: Decodable, Encodable {
  var period: Int?
  var unit: FrequencyUnit?
}
enum ExperimentKind: String, Decodable, Encodable {
  case EMBED = "EMBED"
  case POPUP = "POPUP"
  case TOOLTIP = "TOOLTIP"
  case CONFIG = "CONFIG"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try ExperimentKind(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct ExperimentVariant: Decodable, Encodable {
  var id: ID?
  var configs: [VariantConfig]?
  var weight: Int?
}
enum FlexDirection: String, Decodable, Encodable {
  case ROW = "ROW"
  case COLUMN = "COLUMN"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try FlexDirection(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum FontDesign: String, Decodable, Encodable {
  case DEFAULT = "DEFAULT"
  case MONOSPACE = "MONOSPACE"
  case ROUNDED = "ROUNDED"
  case SERIF = "SERIF"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try FontDesign(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum FontWeight: String, Decodable, Encodable {
  case ULTRA_LIGHT = "ULTRA_LIGHT"
  case THIN = "THIN"
  case LIGHT = "LIGHT"
  case REGULAR = "REGULAR"
  case MEDIUM = "MEDIUM"
  case SEMI_BOLD = "SEMI_BOLD"
  case BOLD = "BOLD"
  case HEAVY = "HEAVY"
  case BLACK = "BLACK"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try FontWeight(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct FrameData: Decodable, Encodable {
  var width: Int?
  var height: Int?
  var paddingLeft: Int?
  var paddingRight: Int?
  var paddingTop: Int?
  var paddingBottom: Int?
  var borderRadius: Int?
  var borderTopLeftRadius: Int?
  var borderTopRightRadius: Int?
  var borderBottomRightRadius: Int?
  var borderBottomLeftRadius: Int?
  var borderWidth: Int?
  var borderColor: Color?
  var background: Color?
  var backgroundSrc: String?
  var shadow: BoxShadow?
}
enum FrequencyUnit: String, Decodable, Encodable {
  case MONTH = "MONTH"
  case WEEK = "WEEK"
  case DAY = "DAY"
  case HOUR = "HOUR"
  case MINUTE = "MINUTE"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try FrequencyUnit(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum ImageContentMode: String, Decodable, Encodable {
  case FIT = "FIT"
  case FILL = "FILL"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try ImageContentMode(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum JustifyContent: String, Decodable, Encodable {
  case START = "START"
  case CENTER = "CENTER"
  case END = "END"
  case SPACE_BETWEEN = "SPACE_BETWEEN"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try JustifyContent(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum ModalPresentationStyle: String, Decodable, Encodable {
  case DEPENDS_ON_CONTEXT_OR_FULL_SCREEN = "DEPENDS_ON_CONTEXT_OR_FULL_SCREEN"
  case DEPENDS_ON_CONTEXT_OR_PAGE_SHEET = "DEPENDS_ON_CONTEXT_OR_PAGE_SHEET"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try ModalPresentationStyle(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum ModalScreenSize: String, Decodable, Encodable {
  case MEDIUM = "MEDIUM"
  case LARGE = "LARGE"
  case MEDIUM_AND_LARGE = "MEDIUM_AND_LARGE"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try ModalScreenSize(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct NavigationBackButton: Decodable, Encodable {
  var title: String?
  var color: Color?
  var visible: Boolean?
}
enum Overflow: String, Decodable, Encodable {
  case VISIBLE = "VISIBLE"
  case HIDDEN = "HIDDEN"
  case SCROLL = "SCROLL"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try Overflow(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum PageKind: String, Decodable, Encodable {
  case COMPONENT = "COMPONENT"
  case MODAL = "MODAL"
  case WEBVIEW_MODAL = "WEBVIEW_MODAL"
  case TOOLTIP = "TOOLTIP"
  case TRIGGER = "TRIGGER"
  case LOAD_BALANCER = "LOAD_BALANCER"
  case DISMISSED = "DISMISSED"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try PageKind(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct Property: Decodable, Encodable {
  var name: String?
  var value: String?
  var ptype: PropertyType?
}
enum PropertyType: String, Decodable, Encodable {
  case INTEGER = "INTEGER"
  case STRING = "STRING"
  case TIMESTAMPZ = "TIMESTAMPZ"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try PropertyType(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum TextAlign: String, Decodable, Encodable {
  case NATURAL = "NATURAL"
  case LEFT = "LEFT"
  case CENTER = "CENTER"
  case RIGHT = "RIGHT"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try TextAlign(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct TriggerEventDef: Decodable, Encodable {
  var name: String?
}
enum TriggerEventNameDefs: String, Decodable, Encodable {
  case RETENTION_1 = "RETENTION_1"
  case RETENTION_2_3 = "RETENTION_2_3"
  case RETENTION_4_7 = "RETENTION_4_7"
  case RETENTION_8_14 = "RETENTION_8_14"
  case RETENTION_15 = "RETENTION_15"
  case USER_BOOT_APP = "USER_BOOT_APP"
  case USER_ENTER_TO_APP = "USER_ENTER_TO_APP"
  case USER_ENTER_TO_APP_FIRSTLY = "USER_ENTER_TO_APP_FIRSTLY"
  case USER_ENTER_TO_FOREGROUND = "USER_ENTER_TO_FOREGROUND"
  case N_ERROR_RECORD = "N_ERROR_RECORD"
  case N_ERROR_IN_SDK_RECORD = "N_ERROR_IN_SDK_RECORD"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try TriggerEventNameDefs(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct TriggerSetting: Decodable, Encodable {
  var onTrigger: UIBlockEventDispatcher?
  var trigger: TriggerEventDef?
}
indirect enum UIBlock: Decodable, Encodable {
  case EUIRootBlock(UIRootBlock)
  case EUIPageBlock(UIPageBlock)
  case EUIFlexContainerBlock(UIFlexContainerBlock)
  case EUITextBlock(UITextBlock)
  case EUIImageBlock(UIImageBlock)
  case EUICollectionBlock(UICollectionBlock)
  case EUICarouselBlock(UICarouselBlock)
  case EUITextInputBlock(UITextInputBlock)
  case EUISelectInputBlock(UISelectInputBlock)
  case EUIMultiSelectInputBlock(UIMultiSelectInputBlock)
  case EUISwitchInputBlock(UISwitchInputBlock)
  case unknown

  enum CodingKeys: String, CodingKey {
    case __typename
  }
  enum Typename: String, Decodable {
    case __UIRootBlock = "UIRootBlock"
    case __UIPageBlock = "UIPageBlock"
    case __UIFlexContainerBlock = "UIFlexContainerBlock"
    case __UITextBlock = "UITextBlock"
    case __UIImageBlock = "UIImageBlock"
    case __UICollectionBlock = "UICollectionBlock"
    case __UICarouselBlock = "UICarouselBlock"
    case __UITextInputBlock = "UITextInputBlock"
    case __UISelectInputBlock = "UISelectInputBlock"
    case __UIMultiSelectInputBlock = "UIMultiSelectInputBlock"
    case __UISwitchInputBlock = "UISwitchInputBlock"
    case unknown
  }
  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    let typename = try container.decode(Typename.self, forKey: .__typename)
    let associateContainer = try decoder.singleValueContainer()
    switch typename {
    case .__UIRootBlock:
      let data = try associateContainer.decode(UIRootBlock.self)
      self = .EUIRootBlock(data)
    case .__UIPageBlock:
      let data = try associateContainer.decode(UIPageBlock.self)
      self = .EUIPageBlock(data)
    case .__UIFlexContainerBlock:
      let data = try associateContainer.decode(UIFlexContainerBlock.self)
      self = .EUIFlexContainerBlock(data)
    case .__UITextBlock:
      let data = try associateContainer.decode(UITextBlock.self)
      self = .EUITextBlock(data)
    case .__UIImageBlock:
      let data = try associateContainer.decode(UIImageBlock.self)
      self = .EUIImageBlock(data)
    case .__UICollectionBlock:
      let data = try associateContainer.decode(UICollectionBlock.self)
      self = .EUICollectionBlock(data)
    case .__UICarouselBlock:
      let data = try associateContainer.decode(UICarouselBlock.self)
      self = .EUICarouselBlock(data)
    case .__UITextInputBlock:
      let data = try associateContainer.decode(UITextInputBlock.self)
      self = .EUITextInputBlock(data)
    case .__UISelectInputBlock:
      let data = try associateContainer.decode(UISelectInputBlock.self)
      self = .EUISelectInputBlock(data)
    case .__UIMultiSelectInputBlock:
      let data = try associateContainer.decode(UIMultiSelectInputBlock.self)
      self = .EUIMultiSelectInputBlock(data)
    case .__UISwitchInputBlock:
      let data = try associateContainer.decode(UISwitchInputBlock.self)
      self = .EUISwitchInputBlock(data)
    default:
      self = .unknown
    }
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)

    switch self {
    case .EUIRootBlock(let data):
      try container.encode(Typename.__UIRootBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUIPageBlock(let data):
      try container.encode(Typename.__UIPageBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUIFlexContainerBlock(let data):
      try container.encode(Typename.__UIFlexContainerBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUITextBlock(let data):
      try container.encode(Typename.__UITextBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUIImageBlock(let data):
      try container.encode(Typename.__UIImageBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUICollectionBlock(let data):
      try container.encode(Typename.__UICollectionBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUICarouselBlock(let data):
      try container.encode(Typename.__UICarouselBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUITextInputBlock(let data):
      try container.encode(Typename.__UITextInputBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUISelectInputBlock(let data):
      try container.encode(Typename.__UISelectInputBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUIMultiSelectInputBlock(let data):
      try container.encode(Typename.__UIMultiSelectInputBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .EUISwitchInputBlock(let data):
      try container.encode(Typename.__UISwitchInputBlock.rawValue, forKey: .__typename)
      try data.encode(to: encoder)
    case .unknown:
      try container.encode(Typename.unknown.rawValue, forKey: .__typename)
    }
  }
}
struct UIBlockEventDispatcher: Decodable, Encodable {
  var name: String?
  var destinationPageId: String?
  var deepLink: String?
  var payload: [Property]?
  var requiredFields: [String]?
  var httpRequest: ApiHttpRequest?
  var httpResponseAssertion: ApiHttpResponseAssertion?
}
struct UICarouselBlock: Decodable, Encodable {
  var id: ID?
  var data: UICarouselBlockData?
}
struct UICarouselBlockData: Decodable, Encodable {
  var children: [UIBlock]?
  var frame: FrameData?
  var gap: Int?
  var onClick: UIBlockEventDispatcher?
}
struct UICollectionBlock: Decodable, Encodable {
  var id: ID?
  var data: UICollectionBlockData?
}
struct UICollectionBlockData: Decodable, Encodable {
  var children: [UIBlock]?
  var frame: FrameData?
  var gap: Int?
  var kind: CollectionKind?
  var direction: FlexDirection?
  var reference: String?
  var gridSize: Int?
  var itemWidth: Int?
  var itemHeight: Int?
  var fullItemWidth: Boolean?
  var pageControl: Boolean?
  var autoScroll: Boolean?
  var autoScrollInterval: Float?
  var onClick: UIBlockEventDispatcher?
}
struct UIFlexContainerBlock: Decodable, Encodable {
  var id: ID?
  var data: UIFlexContainerBlockData?
}
struct UIFlexContainerBlockData: Decodable, Encodable {
  var children: [UIBlock]?
  var direction: FlexDirection?
  var justifyContent: JustifyContent?
  var alignItems: AlignItems?
  var gap: Int?
  var frame: FrameData?
  var overflow: Overflow?
  var onClick: UIBlockEventDispatcher?
}
struct UIImageBlock: Decodable, Encodable {
  var id: ID?
  var data: UIImageBlockData?
}
struct UIImageBlockData: Decodable, Encodable {
  var src: String?
  var contentMode: ImageContentMode?
  var frame: FrameData?
  var onClick: UIBlockEventDispatcher?
}
struct UIMultiSelectInputBlock: Decodable, Encodable {
  var id: ID?
  var data: UIMultiSelectInputBlockData?
}
struct UIMultiSelectInputBlockData: Decodable, Encodable {
  var key: String?
  var options: [UISelectInputOption]?
  var value: [String]?
  var placeholder: String?
  var size: Int?
  var color: Color?
  var design: FontDesign?
  var weight: FontWeight?
  var textAlign: TextAlign?
  var frame: FrameData?
}
struct UIPageBlock: Decodable, Encodable {
  var id: ID?
  var name: String?
  var data: UIPageBlockData?
}
struct UIPageBlockData: Decodable, Encodable {
  var kind: PageKind?
  var modalPresentationStyle: ModalPresentationStyle?
  var modalScreenSize: ModalScreenSize?
  var modalNavigationBackButton: NavigationBackButton?
  var modalRespectSafeArea: Boolean?
  var webviewUrl: String?
  var triggerSetting: TriggerSetting?
  var renderAs: UIBlock?
  var position: UIPageBlockPosition?
  var httpRequest: ApiHttpRequest?
  var tooltipSize: UITooltipSize?
  var tooltipAnchor: String?
  var tooltipPlacement: UITooltipPlacement?
  var tooltipTransitionTarget: UITooltipTransitionTarget?
  var props: [Property]?
  var query: String?
}
struct UIPageBlockPosition: Decodable, Encodable {
  var x: Int?
  var y: Int?
}
struct UIRootBlock: Decodable, Encodable {
  var id: ID?
  var data: UIRootBlockData?
}
struct UIRootBlockData: Decodable, Encodable {
  var pages: [UIPageBlock]?
  var currentPageId: ID?
}
struct UISelectInputBlock: Decodable, Encodable {
  var id: ID?
  var data: UISelectInputBlockData?
}
struct UISelectInputBlockData: Decodable, Encodable {
  var key: String?
  var options: [UISelectInputOption]?
  var value: String?
  var placeholder: String?
  var size: Int?
  var color: Color?
  var design: FontDesign?
  var weight: FontWeight?
  var textAlign: TextAlign?
  var frame: FrameData?
}
struct UISelectInputOption: Decodable, Encodable {
  var value: String?
  var label: String?
}
struct UISwitchInputBlock: Decodable, Encodable {
  var id: ID?
  var data: UISwitchInputBlockData?
}
struct UISwitchInputBlockData: Decodable, Encodable {
  var key: String?
  var value: Boolean?
  var checkedColor: Color?
}
struct UITextBlock: Decodable, Encodable {
  var id: ID?
  var data: UITextBlockData?
}
struct UITextBlockData: Decodable, Encodable {
  var value: String?
  var size: Int?
  var color: Color?
  var design: FontDesign?
  var weight: FontWeight?
  var maxLines: Int?
  var frame: FrameData?
  var onClick: UIBlockEventDispatcher?
}
struct UITextInputBlock: Decodable, Encodable {
  var id: ID?
  var data: UITextInputBlockData?
}
struct UITextInputBlockData: Decodable, Encodable {
  var key: String?
  var value: String?
  var placeholder: String?
  var regex: String?
  var errorMessage: UITooltipMessage?
  var keyboardType: UITextInputKeyboardType?
  var secure: Boolean?
  var autocorrect: Boolean?
  var size: Int?
  var color: Color?
  var design: FontDesign?
  var weight: FontWeight?
  var textAlign: TextAlign?
  var frame: FrameData?
}
enum UITextInputKeyboardType: String, Decodable, Encodable {
  case DEFAULT = "DEFAULT"
  case ASCII = "ASCII"
  case EMAIL = "EMAIL"
  case DECIMAL = "DECIMAL"
  case NUMBER = "NUMBER"
  case URI = "URI"
  case ALPHABET = "ALPHABET"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try UITextInputKeyboardType(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct UITooltipMessage: Decodable, Encodable {
  var title: String?
}
enum UITooltipPlacement: String, Decodable, Encodable {
  case TOP_CENTER = "TOP_CENTER"
  case TOP_START = "TOP_START"
  case TOP_END = "TOP_END"
  case BOTTOM_CENTER = "BOTTOM_CENTER"
  case BOTTOM_START = "BOTTOM_START"
  case BOTTOM_END = "BOTTOM_END"
  case LEFT_CENTER = "LEFT_CENTER"
  case LEFT_START = "LEFT_START"
  case LEFT_END = "LEFT_END"
  case RIGHT_CENTER = "RIGHT_CENTER"
  case RIGHT_START = "RIGHT_START"
  case RIGHT_END = "RIGHT_END"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try UITooltipPlacement(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct UITooltipSize: Decodable, Encodable {
  var width: Int?
  var height: Int?
}
enum UITooltipTransitionTarget: String, Decodable, Encodable {
  case ANCHOR = "ANCHOR"
  case SCREEN = "SCREEN"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try UITooltipTransitionTarget(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct UserEventFrequencyCondition: Decodable, Encodable {
  var eventName: String?
  var lookbackPeriod: Int?
  var unit: FrequencyUnit?
  var comparison: ConditionOperator?
  var since: DateTime?
  var threshold: Int?
}
enum UserPropertyType: String, Decodable, Encodable {
  case INTEGER = "INTEGER"
  case DOUBLE = "DOUBLE"
  case STRING = "STRING"
  case TIMESTAMPZ = "TIMESTAMPZ"
  case BOOLEAN = "BOOLEAN"
  case SEMVER = "SEMVER"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try UserPropertyType(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
struct VariantConfig: Decodable, Encodable {
  var key: String?
  var kind: VariantConfigKind?
  var value: String?
}
enum VariantConfigKind: String, Decodable, Encodable {
  case COMPONENT = "COMPONENT"
  case STRING = "STRING"
  case NUMBER = "NUMBER"
  case BOOLEAN = "BOOLEAN"
  case JSON = "JSON"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try VariantConfigKind(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
enum Weekdays: String, Decodable, Encodable {
  case SUNDAY = "SUNDAY"
  case MONDAY = "MONDAY"
  case TUESDAY = "TUESDAY"
  case WEDNESDAY = "WEDNESDAY"
  case THURSDAY = "THURSDAY"
  case FRIDAY = "FRIDAY"
  case SATURDAY = "SATURDAY"
  case unknown = "unknown"
  init(from decoder: Decoder) throws {
    self = try Weekdays(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? .unknown
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}
